package Compute;

import java.util.Arrays;
import java.util.Comparator;
import java.util.PriorityQueue;
import java.util.Scanner;
import java.util.Vector;

class edge {
	int t, cost;

	public edge(int t, int cost) {
		this.t = t;
		this.cost = cost;
	}
}

class Solution {
	Scanner input = new Scanner(System.in);
	int n = input.nextInt(), p = input.nextInt(), k = input.nextInt();
	Vector<Vector<edge>> edges = new Vector<Vector<edge>>();

	int Dijkstra(int mid) {
		int d[] = new int[n];
		Arrays.fill(d, Integer.MAX_VALUE);
		d[0] = 0;
		PriorityQueue<edge> queue = new PriorityQueue<edge>(n, new Comparator<edge>() {
			@Override
			public int compare(edge o1, edge o2) {
				return o1.cost < o2.cost ? -1 : 1;
			}
		});
		queue.offer(new edge(0, 0));
		while (!queue.isEmpty()) {
			edge e = queue.poll();
			if (d[e.t] < e.cost)
				continue;
			for (edge to : edges.get(e.t)) {
				int cost = d[e.t] + (to.cost >= mid ? 1 : 0);
				if (d[to.t] > cost) {
					d[to.t] = cost;
					queue.offer(new edge(to.t, cost));
				}
			}
		}
		return d[n - 1];
	}

	public Solution() {
		int up = 0, lb = 0;
		for (int i = 0; i < n; i++)
			edges.add(new Vector<edge>());
		for (int i = 0; i < p; i++) {
			int f = input.nextInt() - 1, t = input.nextInt() - 1, cost = input.nextInt();
			edges.get(f).add(new edge(t, cost));
			edges.get(t).add(new edge(f, cost));
			up = Math.max(up, cost);
		}
		up += 2;
		int max = up;
		while (up - lb > 1) {
			int mid = (up + lb) >> 1;
			if (Dijkstra(mid) > k) {
				lb = mid;
			} else {
				up = mid;
			}
		}
		System.out.print(lb > max - 2 ? -1 : lb);
	}

}

public class Main {
	public static void main(String[] args) {

		Solution s = new Solution();

	}

}
=============================================================
假设最小花费为mid,那么长度大于mid的最多只能k个,
将length >= mid 类比为1花费,length < mid的花费为0,
(等于mid的花费也得为1否则的话，表示的就是花费<mid)
那么通过Dijkstra算法最后算出来的最小花费就是大于mid的个数
