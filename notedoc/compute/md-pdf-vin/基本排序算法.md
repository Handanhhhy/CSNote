### 基本排序算法

测试框架

```C++
#include<iostream>
#include<algorithm>
using namespace std;
const int N = 10;
int num[] = { 22, 34, 3, 32, 82, 55, 89, 50, 37, 5, 64, 35, 9, 70 };
void my_swap(int &a, int &b) {
	int temp = a;
	a = b; b = temp;
}

int main() {
	int len = (int) sizeof(num) / sizeof(*num);
	//bubble_sort(num, len);
	//selection_sort(num, len);
	//insertion_sort(num, len);
	//shell_sort(num, len);
	return 0;
}
```



#### 冒泡排序

遍历序列，对序列元素进行`len-1`次两两比较。

```C++
void bubble_sort(int a[], int len) {
	for (int i = 0; i < len - 1; i++) {
		for (int j = 0; j < len - 1; j++) {
			if (a[j] > a[j + 1]) my_swap(a[j], a[j + 1]);
		}
	}
}
```

#### 选择排序

在未排序的序列中选择最小(最大)的放在排序序列中的末尾。(第一个最小元素为排序序列起始)。

```C++
void selection_sort(int a[], int len) {
	for (int i = 0; i < len - 1; i++) {
		for (int j = i + 1; j < len; j++) {
			if (a[i] > a[j])	my_swap(a[i], a[j]);
		}
	}
}
```

#### 插入排序

对于未排序序列数据，选择其中第一位，对排序序列从后向前扫描，将其插入正确位置。

```C++
void insertion_sort(int a[], int len) {
	for (int i = 1; i < len; i++) {
		int temp = a[i], j = -1;
		for (j = i; j > 0 && a[j - 1] > temp; j--)
			a[j] = a[j - 1];
		a[j] = temp;
	}
}
```

#### 希尔排序(减增量排序算法)

基于插入排序的改进版

```C++
void shell_sort(int a[], int len) {
	for (int gap = len >> 1; gap > 0; gap = gap >> 1) {
		for (int i = gap; i < len; i++) {
			int temp = a[i], j = -1;
			for (j = i - gap; j >= 0 && a[j] > temp; j -= gap)
				a[j + gap] = a[j];
			a[j + gap] = temp;
		}
	}
}
```

#### 归并排序

把数据分为两段，从两段中逐个选最小的元素移入新数据段的末尾。

```C++
void merge(int a[], int TempA[], int leftPos, int rightPos, int rightEnd) {
	int i, tempPos = leftPos, leftEnd = rightPos - 1, elements = rightEnd - leftPos + 1;
	while (leftPos <= leftEnd && rightPos <= rightEnd)
	{
		if (a[leftPos] < a[rightPos]) {
			TempA[tempPos++] = a[leftPos++];
		}
		else {
			TempA[tempPos++] = a[rightPos++];
		}
	}
	//如果有单个序列，处理单个序列 一下两个循环最多成立一个
	while (leftPos <= leftEnd) {
		TempA[tempPos++] = a[leftPos++];
	}
	while (rightPos <= rightEnd) {
		TempA[tempPos++] = a[rightPos++];
	}

}
void Msort(int a[], int TempA[], int num, int gap) {
	int i;
	for (i = 0; i <= num - 2 * gap; i += 2 * gap) {
		merge(a, TempA, i, i + gap, i + 2 * gap - 1);
	}
	if (i + gap < num) {
		merge(a, TempA, i, i + gap, num - 1);
	}
	else {
		for (int j = i; j < num; j++) {
			TempA[j] = a[j];
		}
	}
}
void mergeSort(int a[], int num) {
	int *TempA = new int[num];
	if (TempA != nullptr) {
		int gap = 1;
		while (gap < num)
		{
			Msort(a, TempA, num, gap);
			gap = gap << 1;;
			Msort(TempA, a, num, gap);//将归并好的序列倒回原始数组
			gap = gap << 1;
		}
		delete TempA;
	}
}

```



#### 快速排序

```C++
void quickSort(int a[], int left, int right) {
	if(left>right)
		return ;
	int basic = a[left], i = left, j = right;
	while (i != j)
	{
		while (a[j] >= basic && i < j)
			j--;
		while (a[i] <= basic && i < j)
			i++;
		int change = a[i];
		a[i] = a[j];
		a[j] = change;
	}
	a[left] = a[i];
	a[i] = basic;
	quickSort(a, left, i - 1);
	quickSort(a, j + 1, right);
}

```

